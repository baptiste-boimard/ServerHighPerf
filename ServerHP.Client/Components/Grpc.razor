@inject LatencyService.LatencyServiceClient GrpcClient
@using System.Collections.Concurrent
@using global::Grpc.Net.Client
@using Latency;

<div>
    <h3>🚀 Test Latence gRPC</h3>

    <div>
        <h5>Message à envoyer</h5>
        <input @bind="messageText" class="form-control" placeholder="Entrez un message..." />
        <button class="btn btn-primary mt-2" @onclick="SendMessage">Envoyer pour 1 message</button>

        @if (response != null)
        {
            <p><strong>Envoyé :</strong> @response.SentAt.ToDateTime().ToLocalTime().ToString("HH:mm:ss.fff")</p>
            <p><strong>Reçu :</strong> @response.ReceivedAt.ToDateTime().ToLocalTime().ToString("HH:mm:ss.fff")</p>
            <p><strong>Latence :</strong> @((response.ReceivedAt.ToDateTime() - response.SentAt.ToDateTime()).TotalMilliseconds.ToString("F2")) ms</p>
        }
    </div>

    <div class="card p-3 mb-3">
        <h5>Simulation de X clients</h5>
        <div class="d-flex gap-2">
            <input @bind="numberOfClients" type="number" min="1" class="form-control" placeholder="Nombre de clients"/>
            <button class="btn btn-success" @onclick="StartSimulation">Démarrer</button>
            <button class="btn btn-danger" @onclick="StopSimulation" disabled="@(!isRunning)">Stop</button>
        </div>
        <p class="mt-2">Clients actifs : @activeClients</p>
    </div>

    @if (isStopping)
    {
        <div class="alert alert-warning">⏳ Arrêt en cours...</div>
    }

    <div class="mt-3">
        <h6>📊 Messages reçus :</h6>
        <div style="height: 350px; overflow-y: auto; border: 1px solid #ccc;">
            <table class="table table-sm table-striped mb-0">
                <thead class="table-light" style="position: sticky; top: 0; background: white;">
                <tr>
                    <th scope="col" style="width: 80px">Client</th>
                    <th scope="col" style="width: 150px">Message</th>
                    <th scope="col" style="width: 150px">Envoyé</th>
                    <th scope="col" style="width: 150px">Reçu</th>
                    <th scope="col" style="width: 150px">Latence (ms)</th>
                </tr>
                </thead>
                <tbody>
                @foreach (var msg in receivedMessages.Take(100))
                {
                    var sent = msg.SentAt.ToDateTime().ToLocalTime();
                    var received = msg.ReceivedAt.ToDateTime().ToLocalTime();
                    var latency = (received - sent).TotalMilliseconds;

                    <tr>
                        <td>@msg.Id.Substring(0, 6)</td>
                        <td>@msg.SentContent</td>
                        <td>@sent.ToString("HH:mm:ss.fff")</td>
                        <td>@received.ToString("HH:mm:ss.fff")</td>
                        <td>@latency.ToString("F2")</td>
                    </tr>
                }
                </tbody>
            </table>
        </div>
    </div>

    @if (receivedMessages.Count > 0)
    {
        <div>
            <h6>📈 Statistiques</h6>
            <ul>
                <li><strong>Moyenne :</strong> @AverageLatency?.ToString("F2") ms</li>
                <li><strong>Médiane :</strong> @MedianLatency?.ToString("F2") ms</li>
                <li><strong>Min :</strong> @MinLatency?.ToString("F2") ms</li>
                <li><strong>Max :</strong> @MaxLatency?.ToString("F2") ms</li>
            </ul>
        </div>
    }
</div>




@code {
    private string messageText = "";
    private MessageResponse? response;
    
    private int numberOfClients = 10;
    private int activeClients = 0;
    private bool isRunning = false;
    private bool isStopping = false;

    private CancellationTokenSource? cts;
    private List<Task> clientTasks = new();
    private ConcurrentQueue<MessageResponse> messageQueue = new();
    private List<MessageResponse> receivedMessages = new();
    
    private static readonly GrpcChannel channel = GrpcChannel.ForAddress("http://localhost:5024");
    private static readonly LatencyService.LatencyServiceClient sharedClient = new(channel);

    private double? AverageLatency
    {
        get
        {
            lock (receivedMessages)
            {
                return receivedMessages.Count > 0
                    ? receivedMessages.Average(m => (m.ReceivedAt.ToDateTime() - m.SentAt.ToDateTime()).TotalMilliseconds)
                    : null;
            }
        }
    }

    private double? MinLatency
    {
        get
        {
            lock (receivedMessages)
            {
                return receivedMessages.Count > 0
                    ? receivedMessages.Min(m => (m.ReceivedAt.ToDateTime() - m.SentAt.ToDateTime()).TotalMilliseconds)
                    : null;
            }
        }
    }

    private double? MaxLatency
    {
        get
        {
            lock (receivedMessages)
            {
                return receivedMessages.Count > 0
                    ? receivedMessages.Max(m => (m.ReceivedAt.ToDateTime() - m.SentAt.ToDateTime()).TotalMilliseconds)
                    : null;
            }
        }
    }

    private double? MedianLatency
    {
        get
        {
            lock (receivedMessages)
            {
                var list = receivedMessages
                    .Select(m => (m.ReceivedAt.ToDateTime() - m.SentAt.ToDateTime()).TotalMilliseconds)
                    .OrderBy(x => x)
                    .ToList();

                if (list.Count == 0) return null;

                int middle = list.Count / 2;
                return list.Count % 2 == 0
                    ? (list[middle - 1] + list[middle]) / 2
                    : list[middle];
            }
        }
    }


    private async Task SendMessage()
    {
        var msg = new MessageInfo
        {
            Id = Guid.NewGuid().ToString(),
            SentContent = messageText,
            SentAt = Timestamp.FromDateTime(DateTime.UtcNow)
        };

        response = await GrpcClient.SendMessageAsync(msg);
    }
    
    private async Task StartSimulation()
    {
        StopSimulation();

        cts = new CancellationTokenSource();
        isStopping = false;
        isRunning = true;
        activeClients = 0;
        receivedMessages.Clear();
        clientTasks.Clear();

        for (int i = 0; i < numberOfClients; i++)
        {
            int clientId = i;
            var task = Task.Run(() => SimulateClient(clientId, cts.Token));
            clientTasks.Add(task);
            activeClients++;
        }

        await Task.Delay(50);
        StateHasChanged();
    }

    private async Task SimulateClient(int clientId, CancellationToken token)
    {
        try
        {
            while (!token.IsCancellationRequested)
            {
                var now = DateTime.UtcNow;

                var request = new MessageInfo
                {
                    Id = Guid.NewGuid().ToString(),
                    SentContent = messageText,
                    SentAt = Timestamp.FromDateTime(now)
                };

                var response = await sharedClient.SendMessageAsync(request, cancellationToken: token);
                
                lock (receivedMessages)
                {
                    receivedMessages.Insert(0, response);
                    if (receivedMessages.Count > 100)
                        receivedMessages.RemoveAt(receivedMessages.Count - 1);
                }

                await InvokeAsync(StateHasChanged);
                await Task.Delay(1000, token);
            }
        }
        catch
        {
            // Ignore cancellation
        }
        finally
        {
            activeClients--;
            if (activeClients == 0 && isStopping)
            {
                isRunning = false;
                isStopping = false;
                await InvokeAsync(StateHasChanged);
            }
        }
    }

    private void StopSimulation()
    {
        isStopping = true;
        isRunning = false;

        cts?.Cancel();
        cts?.Dispose();
        cts = null;
    }
}